{% extends "main.njk" %}

{% block content %}

<h2>Joint in Practice</h2>

<p>
  To implement solutions with the Joint Kit, you create <i>Joints</i>.
</p>

<p>
  A Joint connects to:
</p>

<ul class="definition">
  <li>
    <div style="width:180px">your persistence service</div>
    <div style="width:27px">&#10132;</div>
    <div>to implement a data method layer</div>
  </li>
  <li>
    <div style="width:180px">your server framework</div>
    <div style="width:27px">&#10132;</div>
    <div>to implement an HTTP API layer</div>
  </li>
</ul>

<p style="margin-top:30px">
  The Joint Kit provides a set of data actions that are abstracted to handle common data operations for your resources.
  Actions are implemented using a config-like JSON syntax, making development simple and quick.
</p>

<p>
  Leverage the built-in features to satisfy 100% of your required functionality, or use them as a base, to augment with your own specialized logic.
</p>

<h3>Create a Joint</h3>

<div class="code-filename">
  <span>/joint/index.js</span>
</div>

<div class="code-block">
<pre>
import Joint from 'joint-kit';
import bookshelf from '../services/bookshelf'; <comment>// your configured bookshelf instance</comment>

const joint = new Joint({
  service: bookshelf,
});

export default joint;
</pre>
</div>

<h3>Define Data Models</h3>

<p>
  Define your data models using a JSON descriptor:
</p>

<div class="code-filename">
  <span>/joint/model-config.js</span>
</div>

<div class="code-block">
<pre>
export default {
  models: {
    <comment>// Define a model named: "Profile"</comment>
    Profile: {
      tableName: 'blog_profiles',
      timestamps: { created: 'created_at', updated: 'updated_at' },
      associations: {
        user: {
          type: 'toOne',
          path: 'user_id => User.id', <comment>// one-to-one</comment>
        },
        posts: {
          type: 'toMany',
          path: 'id => BlogPost.profile_id', <comment>// one-to-many</comment>
        },
        tags: {
          type: 'toMany',
          path: 'id => ProfileTag.profile_id => ProfileTag.tag_id => Tag.id', <comment>// many-to-many</comment>
        },
      },
    },
  },
};
</pre>
</div>

<br />

<p>
  Use the <func>generate</func> <span>func</span>tion to dynamically build and register your models:
</p>

<callout>
  Models are registered as: &nbsp; <code>joint.model.&lt;modelName&gt;</code>
</callout>

<div class="code-filename">
  <span>/joint/index.js</span>
</div>

<div class="code-block">
<pre>
import Joint from 'joint-kit';
import bookshelf from '../services/bookshelf';
<hilite>import modelConfig from './model-config';</hilite>

const joint = new Joint({
  service: bookshelf,
});

<hilite>joint.generate({ modelConfig });</hilite> <comment>// generate the models</comment>

if (joint.model.Profile) console.log('The Profile model exists !!!');

export default joint;
</pre>
</div>

<h3>Create a Method Library</h3>

<p>
  From the provided set of abstract data actions (<a href="{{ rootURI }}/api/joint-actions">Joint Actions</a>), you can quickly implement a customized method library.
</p>

<p>
  You can hand-roll the methods yourself:
</p>

<details>
<summary>Hand-rolling a CRUD set of methods</summary>

<div class="code-filename">
  <span>/methods/profile.js</span>
</div>

<div class="code-block">
<pre>
import joint from '../joint';

export function createProfile(input) {
  const spec = {
    modelName: 'Profile',
    fields: [
      { name: 'user_id', type: 'Number', required: true },
      { name: 'title', type: 'String', required: true },
      { name: 'slug', type: 'String', defaultValue: '% kebabCase(title) %' },
      { name: 'tagline', type: 'String' },
      { name: 'is_live', type: 'Boolean', defaultValue: false },
    ],
  };

  return joint.createItem(spec, input);
}

export function updateProfile(input) {
  const spec = {
    modelName: 'Profile',
    fields: [
      { name: 'id', type: 'Number', required: true, lookup: true },
      { name: 'title', type: 'String' },
      { name: 'slug', type: 'String' },
      { name: 'tagline', type: 'String' },
      { name: 'is_live', type: 'Boolean' },
    ],
  };

  return joint.updateItem(spec, input);
}

export function getProfile(input) {
  const spec = {
    modelName: 'Profile',
    fields: [
      { name: 'id', type: 'Number', requiredOr: true },
      { name: 'slug', type: 'String', requiredOr: true },
    ],
  };

  return joint.getItem(spec, input);
}

export function getProfiles(input) {
  const spec = {
    modelName: 'Profile',
    fields: [
      { name: 'user_id', type: 'Number' },
      { name: 'is_live', type: 'Boolean' },
    ],
    defaultOrderBy: '-created_at,title',
  };

  return joint.getItems(spec, input);
}

export function deleteProfile(input) {
  const spec = {
    modelName: 'Profile',
    fields: [
      { name: 'id', type: 'Number', requiredOr: true },
      { name: 'slug', type: 'String', requiredOr: true },
    ],
  };

  return joint.deleteItem(spec, input);
}
</pre>
</div>
</details>

<dangle>-<span>or</span>-</dangle>

<p>
  You can define the methods using a JSON descriptor:
</p>

<div class="code-filename">
  <span>/joint/method-config.js</span>
</div>

<div class="code-block">
<pre>
export default {
  resources: [
    {
      modelName: 'Profile',
      methods: [
        {
          name: 'createProfile',
          action: 'createItem',
          spec: {
            fields: [
              { name: 'user_id', type: 'Number', required: true },
              { name: 'title', type: 'String', required: true },
              { name: 'slug', type: 'String', defaultValue: '% kebabCase(title) %' },
              { name: 'tagline', type: 'String' },
              { name: 'is_live', type: 'Boolean', defaultValue: false },
            ],
          },
        },
        {
          name: 'updateProfile',
          action: 'updateItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', required: true, lookup: true },
              { name: 'title', type: 'String' },
              { name: 'slug', type: 'String' },
              { name: 'tagline', type: 'String' },
              { name: 'is_live', type: 'Boolean' },
            ],
          },
        },
        {
          name: 'getProfile',
          action: 'getItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', requiredOr: true },
              { name: 'slug', type: 'String', requiredOr: true },
            ],
          },
        },
        {
          name: 'getProfiles',
          action: 'getItems',
          spec: {
            fields: [
              { name: 'user_id', type: 'Number' },
              { name: 'is_live', type: 'Boolean' },
            ],
            defaultOrderBy: '-created_at,title',
          },
        },
        {
          name: 'deleteProfile',
          action: 'deleteItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', requiredOr: true },
              { name: 'slug', type: 'String', requiredOr: true },
            ],
          },
        },
      ],
    },
  ],
};
</pre>
</div>

<br />

<p>
  Use the <func>generate</func> <span>func</span>tion to dynamically generate your methods:
</p>

<callout>
  Methods are registered as: &nbsp; <code>joint.model.&lt;modelName&gt;.&lt;methodName&gt;</code>
</callout>

<div class="code-filename">
  <span>/joint/index.js</span>
</div>

<div class="code-block">
<pre>
import Joint from 'joint-kit';
import bookshelf from '../services/bookshelf';
import modelConfig from './model-config';
<hilite>import methodConfig from './method-config';</hilite>

const joint = new Joint({
  service: bookshelf,
});

<hilite>joint.generate</hilite>({ modelConfig, <hilite>methodConfig</hilite> });</hilite> <comment>// generate the methods</comment>

const input = {
  fields: { is_live: true }, <comment>// retrieve all "live" profiles</comment>
};

joint.method.Profile.getProfiles(input)
  .then((result) => { ... })
  .catch((error) => { ... });

export default joint;
</pre>
</div>

<h3>Create RESTful Endpoints</h3>

<p>
  On top of your Joint methods, you can quickly expose a RESTful API layer.
</p>

<p>
  You can hand-roll the router yourself:
</p>

<details>
<summary>Hand-rolling a router</summary>

<div class="code-filename">
  <span>/router/profile.js</span>
</div>

<div class="code-block">
<pre>
import joint from '../joint';

</pre>
</div>
</details>

<dangle>-<span>or</span>-</dangle>

<p>
  You can define the router using a JSON descriptor:
</p>

<div class="code-filename">
  <span>/joint/route-config.js</span>
</div>

<div class="code-block">
<pre>
export default {
  routes: [
    {
      uri: '/profile',
      post: { method: 'Profile.createProfile', successStatus: 201, body: true },
    },
    {
      uri: '/profile/:id',
      get: { method: 'Profile.getProfile' },
      post: { method: 'Profile.updateProfile', body: true },
      delete: { method: 'Profile.deleteProfile', successStatus: 204 },
    },
    {
      uri: '/profiles',
      get: { method: 'Profile.getProfiles' },
    },
  ],
};
</pre>
</div>

<br />

<p>
  Use the <func>generate</func> <span>func</span>tion to dynamically generate your router:
</p>

<callout>
  The router is registered as: &nbsp; <code>joint.router</code>
</callout>

<div class="code-filename">
  <span>/joint/index.js</span>
</div>

<div class="code-block">
<pre>
import Joint from 'joint-kit';
<hilite>import express from 'express';</hilite>
import bookshelf from '../services/bookshelf';
import modelConfig from './model-config';
import methodConfig from './method-config';
<hilite>import routeConfig from './route-config';</hilite>

const joint = new Joint({
  service: bookshelf,
  <hilite>server: express,</hilite>
});

<hilite>joint.generate</hilite>({ modelConfig, methodConfig, <hilite>routeConfig</hilite> });</hilite> <comment>// generate the router</comment>

const app = express();
app.use('/api', joint.router); <comment>// provide the router to your server</comment>

<comment>// Now serving: GET /api/profile/333</comment>

export default joint;
</pre>
</div>

{% endblock %}
