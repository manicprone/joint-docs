{% extends "main.njk" %}

{% block content %}

<h2>Conceptual Walkthrough</h2>

<p>
  So, you want to build a Node app.
</p>

<p>
  If your app requires accessing and/or modifying data from a
  database... the Joint Kit can help.
</p>

<br />

<p>
  Let&#39;s say you want to build a simple blogging service.
</p>

<p>
  The service will:

  <ul>
    <li>Manage user accounts (for administrators and bloggers)</li>
    <li>Manage user roles (for granting authorization)</li>
    <li>Manage payment methods for paying subscribers (a user can have multiple)</li>
    <li>Manage one blog profile per user (for their public identity)</li>
    <li>Manage the blog posts created by a blog profile</li>
    <li>Provide a RESTful API, so a client application can render the UI.</li>
  </ul>
</p>

<br />

<p>
  First, get your database prepared and your table schema created.
</p>

<p>
  [TBC - Diagram of data schema]
</p>

<br />

<p>
  Then, connect your app to the database using your persistence service.
  (Currently, Bookshelf is the only supported option)
</p>

<details class="third-party">
<summary>Connecting to your database using Bookshelf</summary>

{% call code.block(filename='/services/bookshelf.js') -%}
<comment>// Configure knex connection...</comment>
const knex = require('knex')({
  client: 'pg',
  connection: {
    host: '127.0.0.1',
    port: '5432',
    database: 'simple_blog',
    user: 'simple_blog_app',
    password: 'simple_blog_app_password',
  },
  useNullAsDefault: true,
});

<comment>// Initialize bookshelf...</comment>
const bookshelf = require('bookshelf')(knex);

<comment>// Enable required plugins...</comment>
bookshelf.plugin('registry');
bookshelf.plugin('pagination');

export default bookshelf;
{%- endcall %}
</details>

<br />

<p>
  Now, the Joint Kit can take it from here...
</p>

<br />

<p>
  To implement solutions with the Joint Kit, you create <i>Joints</i>.

  <lilp>
  You can think of Joints as isolated data services.
  Each Joint hooks to a specific data repository, interacts only with the data
  it is permitted, and performs independently-configured behavior.
  </lilp>
</p>

<br />

<p>
  Let&#39;s look at using the Joint Kit to handle our user data requirements.
</p>

<br />

<p>
  Create a Joint, providing your configured Bookshelf instance.
</p>

{% call code.block(filename='/joint/index.js') -%}
import Joint from 'joint-kit';
import bookshelf from '../services/bookshelf';

const joint = new Joint({
  service: bookshelf,
});

export default joint;
{%- endcall %}

<br />

<p>
  To generate a Promise-based method library for your app to use,
  you must define two things: your data objects (models)
  and the operations (methods) to expose for each model.
</p>

<br />

<p>
  For model definitions, you create a <b>model config</b>.

  <lilp>
  The effort for configuring data models is effectively mapping a logical name
  to each of your tables, and defining any relationships (associations) that
  exist amongst them.
  </lilp>
</p>

<callout>
  [TBC - Mention using the service natively] ...your models will be mixed-in...
</callout>

{% call code.block(filename='/joint/model-config.js') -%}
export default {
  models: {

    Role: {
      tableName: 'user_role',
    },

    UserRoleRef: {
      tableName: 'user_role_ref',
    },

    Profile: {
      tableName: 'blog_profile',
      associations: {
        user: {
          type: 'toOne',
          path: 'user_id => User.id', <comment>// one-to-one</comment>
        },
        posts: {
          type: 'toMany',
          path: 'id => Post.profile_id', <comment>// one-to-many</comment>
        },
      },
    },

    Post: {
      tableName: 'blog_post',
      associations: {
        profile: {
          type: 'toOne',
          path: 'profile_id => Profile.id', <comment>// one-to-one</comment>
        },
      },
    },

    User: {
      tableName: 'user_account',
      associations: {
        profile: {
          type: 'toOne',
          path: 'id => Profile.user_id', <comment>// one-to-one</comment>
        },
        roles: {
          type: 'toMany',
          path: 'id => UserRoleRef.user_id => UserRoleRef.role_id => Role.id', <comment>// many-to-many</comment>
        },
      },
    },

  },
};
{%- endcall %}

<br />

<p>
  For method definitions, you create a <b>method config</b>.

  <lilp>
  Defining the operations for a model involves: specifying the model name,
  providing a method name that you can use in your code, selecting the appropriate
  Joint Action to handle the core logic, and then defining any custom rules or behavior
  specific to your requirements.
</p>

<callout>
  [TBC - Mention hand-rolling option] You can also use the Joint programmatically.
</callout>

{% call code.block(filename='/joint/method-config.js') -%}
export default {
  resources: [
    {
      modelName: 'Profile',
      methods: [
        {
          name: 'createProfile',
          action: 'createItem',
          spec: {
            fields: [
              { name: 'user_id', type: 'Number', required: true },
              { name: 'title', type: 'String', required: true },
              { name: 'slug', type: 'String', defaultValue: '% kebabCase(title) %' },
              { name: 'tagline', type: 'String' },
              { name: 'is_live', type: 'Boolean', defaultValue: false },
            ],
          },
        },
        {
          name: 'updateProfile',
          action: 'updateItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', required: true, lookup: true },
              { name: 'title', type: 'String' },
              { name: 'slug', type: 'String' },
              { name: 'tagline', type: 'String' },
              { name: 'is_live', type: 'Boolean' },
            ],
          },
        },
        {
          name: 'getProfile',
          action: 'getItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', requiredOr: true },
              { name: 'slug', type: 'String', requiredOr: true },
            ],
          },
        },
        {
          name: 'getProfiles',
          action: 'getItems',
          spec: {
            fields: [
              { name: 'user_id', type: 'Number' },
              { name: 'is_live', type: 'Boolean' },
            ],
            defaultOrderBy: '-created_at,title',
          },
        },
        {
          name: 'deleteProfile',
          action: 'deleteItem',
          spec: {
            fields: [
              { name: 'id', type: 'Number', requiredOr: true },
              { name: 'slug', type: 'String', requiredOr: true },
            ],
          },
        },
      ],
    },
  ],
};
{%- endcall %}

<p>
  Now, run the <code>generate</code> function on your configuration,
  and the methods will be available from your Joint instance.
</p>

{% endblock %}
